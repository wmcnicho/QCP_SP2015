\documentclass[bibliography=totocnumbered, 10pt]{article}
%\usepackage[T1]{fontenc} Verpixelt!

%\bibliographystyle{plain}

\usepackage{geometry}
\geometry{a4paper, left=30mm, right=30mm, top=45mm, bottom=35mm}

\usepackage[utf8]{inputenc}
%\usepackage[german]{babel}
%\usepackage{sistyle}
%\usepackage{paralist}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage[usenames,dvipsnames]{color}
\usepackage{forloop}
\usepackage{icomma}
\usepackage{rotating}
\usepackage{multirow}
\usepackage{wasysym}
\usepackage{amsthm}
\usepackage{array}
\usepackage{enumerate} % for producing lists indexed with letters
\usepackage{epstopdf}
\epstopdfsetup{update}

\input{inc/Qcircuit}

\usepackage{physics}

\usepackage[final]{pdfpages}

%\usepackage[style=authortitle-icomp]{biblatex}
%\usepackage[babel,german=guillemets]{csquotes}
%\bibliography{lit} 

%\usepackage{floatflt}



\usepackage[margin=5pt, font=small,labelfont=bf]{caption} %Sehr geiles Package
\usepackage[margin=10pt, list=true, font=small, labelfont=bf, labelformat=brace, position=top]{subcaption} %Sehr geiles Package


\usepackage{verbatim}
%\usepackage{sverb}
\usepackage{listings}
\usepackage{courier} %computer font

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\definecolor{mylinkColor}{rgb}{0,0.14,0.4}

\setlength{\fboxrule}{0.3mm}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\tiny,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


%Kopfzeile
\usepackage{fancyhdr}
\usepackage{lastpage}
\pagestyle{fancy}
\fancyhf{} %Löscht Voreinstellungen
\lhead{\nouppercase{\leftmark}}
\rhead{Page \thepage \ of \pageref{LastPage}}
%Kopfzeile Ende

%-----------------------------------------------------------------------------------------
% TITELBLATT
%-----------------------------------------------------------------------------------------
\newcommand{\titlename}{}

\newcommand{\authorname}{Michael Chiang, Gennaro di Pietro, William McNichols \& Christoph Meßmer}

\newcommand{\citeS}[1]{\textsuperscript{\cite{#1}}}
\newcommand{\imgref}[1]{Fig.\,\ref{#1}}

%\newcommand{\captionS}[1]{\textbf{\caption{\normalfont{\small #1}}}}





{\small }

\title{
 \titlename\\
  \vspace{2cm}
  %\includegraphics[width=\textwidth]{Bilder/Title.PNG}
  \vspace{1cm}
}
\author{\authorname}
\date{}

\usepackage{hyperref} 
\usepackage{wrapfig}

\usepackage[all]{hypcap} %Damit Verlinkungen auf Bilder richtig gemacht werden




\hypersetup{
    bookmarks=true,         % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=false,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={\titlename},    % title
    pdfauthor={\authorname},     % author
    pdfsubject={},   % subject of the document
    pdfcreator={},   % creator of the document
    pdfproducer={}, % producer of the document
    pdfkeywords={}, % list of keywords
    pdfnewwindow=true,      % links in new window
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=mylinkColor,          % color of internal links (change box color with linkbordercolor)
    citecolor=OliveGreen,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}

\newtheorem{definition}{Definition}[section]
\newtheorem{bsp}[definition]{Example}

\newtheoremstyle{NoticeStyle}% name of the style to be used
  {}% measure of space to leave above the theorem. E.g.: 3pt
  {}% measure of space to leave below the theorem. E.g.: 3pt
  {}% name of font to use in the body of the theorem
  {}% measure of space to indent
  {}% name of head font
  {}% punctuation between head and body
  {}% space after theorem head; " " = normal interword space
  {}% Manually specify head
 
\theoremstyle{NoticeStyle}

\newcommand{\Anmerkung}[1]{
	
	\vspace{3pt}
	\begin{tabular}{||p{0.9\textwidth}}
		\textsc{Notice:} {\small #1}
	\end{tabular}
	
	\vspace{3pt}
}


\begin{document}

\newpage
\begin{titlepage}
	\centering
	{\LARGE \textsc{The University of Edinburgh}}\\[5pt]
	{\large \textsc{School of Physics and Astronomy}}\\
	\vspace{80pt}
	
	\rule{\linewidth}{1pt}
	{
	\textbf{\LARGE Quantum Computing Project:\\Report}
	}
	\rule{\linewidth}{1pt}
	
%	\vspace{80pt}
%	{\large
%	A report\\as part of\\
%	\textbf{}\\
%	}
	\vspace{80pt}
	{\large
		
	}
	
	\vspace{200pt}
	{\large
	by\\
	\textsc{Michael Chiang\\
	Gennaro di Pietro\\
	William McNichols\\
	Christoph Meßmer}
	}
	\vfill
	{\large Edinburgh, 24th of March 2015}
\end{titlepage}

\newpage


%-----------------------------------------------------------------------------------------
% INHALTSVERZEICHNIS
%-----------------------------------------------------------------------------------------
\tableofcontents
\newpage


%-----------------------------------------------------------------------------------------
% INTRODUCTION
%-----------------------------------------------------------------------------------------
%
\section{Introduction}
%Provide an introduction of quantum computing at the level of the knowledge you had at the start of the course
This report is an accumulation of knowledge and results from the course 'Quantum Computing Project' at the University of Edinburgh and is meant to be comprehensible to 3rd year undergraduate students of physical science (especially informatics and physics).

The report will begin by describing the \hyperref[sec:Aims]{aims} of the project and providing a \hyperref[sec:Background]{background} for the topic of Quantum Computing. That is followed by a chapter about the \hyperref[sec:Theory]{theory} needed for the underlying mathematics of the program which is purposely not intended to be exhaustive (see \hyperref[sec:References]{references} for further information).

After that we will describe the \hyperref[sec:Implementation]{implementation} of the project including how we organised the programming, which development environment we used, how we structured the program, etc.

We finish with a chapter about the \hyperref[sec:Results]{results} followed by a \hyperref[sec:Discussion]{discussion} of these results and what we would do differently if we were to recreate the programme.


\subsection{Aims}\label{sec:Aims}

The aims of the project:
\begin{itemize}
	\item \textbf{Comprehend quantum computing}\\
	One goal is to get familiar with quantum computing as a generalisation of conventional computing.
	\item \textbf{Programming}\\
	The main goal is to simulate a quantum computer on a conventional classical computer. This includes programming basic concepts like \hyperref[sec:Qubits]{qubits}, \hyperref[sec:Quantum register]{quantum registers} and \hyperref[sec:Quantum gates]{quantum gates}. Finally it should be possible to run \hyperref[sec:Quantum algorithms]{quantum algorithms} like \hyperref[sec:Grover]{Grover's algorithm} (optional: \hyperref[sec:Shor]{Shor's algorithm}).
	\item \textbf{Presenting results}\\
	This includes not only this report and a verbal presentation but also proper documentation of the programming code to make it comprehensive to other programmers.
	\item \textbf{Teamwork and organisation}\\
	A project like this needs organisation and division of tasks but also successful communication between all group members. It is a further goal to encourage teamwork and organisation skills.
\end{itemize} 

\subsection{Background}\label{sec:Background}

The history of computers reaches back to the middle of the 19th century when a design for an Analytical Engine
was proposed by Charles Babbage, one of the early pioneers of computation. However, for almost 100 years this branch stayed as an interesting but rather conceptional one until the invention of the transistor in 1925. The transistor was the core of classical computers as it provided a physical mechanism for reliably storing a bit of information that could be easily adjusted between two possible states. The first working computers were built in the 1940s and up to today computers work principally the same way. 

Quantum computation on the other hand is a quite recent research field which emerged from the physics of quantum mechanics (1920s). In 1982 Richard Feynman theorised that there seemed to be essential difficulties in simulating quantum mechanical system on classical computers and suggested that a quantum computer would solve these issues.\citeS{Nielsen2010} At its core a quantum computer would not be limited to two states for each unit during computation but could theoretically be in any superposition of the units in it's circuit (see \hyperref[sec:Quantum Register]{quantum register}).

The increased flexibility of a quantum computation led to remarkable theoretical breakthroughs in the 1990s, when Peter \textbf{Shor} demonstrated that essential problems -- like factorising integers -- could be solved far more efficiently on quantum computers than on conventional, classical computers. Besides Shor's algorithm Lov \textbf{Grover} proposed another algorithm in 1995 (only one year later) showing that the problem of conducting a search through some unstructured search space is as well more efficient on quantum computers.
%•	Comparison between classical and quantum computing
%•	Practical challenges for building a quantum computer

The practical challenges for building a quantum computer are high and therefore the realisation of real quantum computers is still in it's infancy. However, in 2001 the first real quantum computer was able to factorise 15 into its prime numbers (3 and 5) by using a 7-qubit system.\citeS{ShorsAlgoReal} Since then experimental progress is booming but the state-of-the-art is still a fair way off from practical (and even less daily-life) usage.


%-----------------------------------------------------------------------------------------
% THEORY
%-----------------------------------------------------------------------------------------
%
\section{Theory}\label{sec:Theory}

In this chapter we introduce the basic concepts of quantum computation, starting off with definitions of \hyperref[sec:Qubits]{\textbf{qubits}}, \hyperref[sec:Quantum register]{\textbf{quantum registers}} and the presentation of several \hyperref[sec:Quantum gates]{\textbf{quantum gates}}. Afterwards we will talk about two \hyperref[sec:Quantum algorithms]{\textbf{quantum algorithms}} that we implemented in our virtual quantum computer. The last chapter will briefly talk about the challenges of \hyperref[sec:Building a quantum computer]{\textbf{building a real quantum computer}}.

\subsection{Qubits}\label{sec:Qubits}

\subsubsection{Generalised bits}
A qubit (from \textit{qu}antum \textit{bit}) is the smallest unit in a quantum computer and therefore the quantum mechanical \textbf{generalisation of a classical bit}, as it is used in computers nowadays. A classical bit has one and only one of the two possible states
%
\begin{align}
	\ket{0} \quad \text{or} \quad \ket{1}
\end{align}
%
at the same time, whereas a qubit is able to be in a state $\ket{\Psi}$ which is a superposition of these two classical states:
%
\begin{align}
	\ket{\Psi} = \alpha \ket{0} + \beta \ket{1}, \quad \text{where }|\alpha|^2 + |\beta|^2 = 1	\label{eq:Superpos of qubit}
\end{align}
%
%
One can depict the states via matrices with basis $(\ket{0}, \ket{1})$:
\begin{align}
	\ket{0} = \begin{pmatrix}1\\0 \end{pmatrix}, \quad\quad \ket{1} = \begin{pmatrix}0\\1 \end{pmatrix}, \quad\quad \ket{\Psi} = \begin{pmatrix}\alpha\\\beta \end{pmatrix}
\end{align}


\subsubsection{Measurement}
The superposition of states leads to a new understanding of measurement. There are two things to consider:
\begin{enumerate}
	\item \textbf{Probabilities $P$}\\
	Given a classical state ($\ket{\Psi}$ either $\ket{0}$ or $\ket{1}$) the result of a measurement is certain (and trivial). That's no longer true for the quantum state: Given the state $\ket{\Psi}$ in Eq.\,\ref{eq:Superpos of qubit}, it is solely possible to calculate the \textbf{probabilities $P_\Psi$} of the outcome:
	%
	\begin{align}
		P_\Psi(0) = \left|\braket{0}{\Psi}\right|^2 &= \left|   \alpha \underbrace{\braket{0}{0}}_{=1} + \beta \underbrace{\braket{0}{1}}_{=0}   \right|^2 = |\alpha|^2\\
		P_\Psi(1) = \left|\braket{1}{\Psi}\right|^2 &= \left|   \alpha \underbrace{\braket{1}{0}}_{=0} + \beta \underbrace{\braket{1}{1}}_{=1}   \right|^2 = |\beta|^2
	\end{align}
	
	\item \textbf{Collapse of $\ket{\Psi}$}\\
	In classical measurements it is fair to say that the measurement itself has no (noticeable) influence on the result. This is no longer true in quantum mechanics: The wave function $\ket{\Psi}_i$ \textbf{collapses after a measurement} to a projection onto the measured eigenstate and therefore becomes a different state $\ket{\Psi}_f$:
	%
	\begin{align}
		\ket{\Psi}_i = \alpha \ket{0} + \beta \ket{1}
		\quad
		\xrightarrow{\text{Measurement:  Value } m}
		\quad
		\ket{\Psi}_f=
		\begin{cases}
			\ket{0} \text{,  if } m=0\\
			\ket{1} \text{,  if } m=1
		\end{cases}
	\end{align}

\end{enumerate}



\subsection{Quantum Register}\label{sec:Quantum register}
A quantum register of size $n$ is a \textbf{collection of $n$ qubits}. Therefore we get $N \equiv 2^n$ basic states:
%
\begin{align}
	\ket{b_{n-1}} \otimes \ket{b_{n-2}} \otimes ... \otimes \ket{b_1} \otimes \ket{b_0}
\end{align}
%
where $b_i \in \{0, 1\}$. One can interpret this chain of zeros and ones as binary code, able to store numbers in the range of $[0, 1, ..., N-1]$. For example for a 3-qubit system we get:
%
\begin{align*}
	\ket{0} \otimes \ket{0} \otimes \ket{0} \equiv \ket{000} \equiv \ket{0} \quad\quad\quad
	\ket{1} \otimes \ket{0} \otimes \ket{0} \equiv \ket{100} \equiv \ket{4}\\
	\ket{0} \otimes \ket{0} \otimes \ket{1} \equiv \ket{001} \equiv \ket{1} \quad\quad\quad
	\ket{1} \otimes \ket{0} \otimes \ket{1} \equiv \ket{101} \equiv \ket{5}\\
	\ket{0} \otimes \ket{1} \otimes \ket{0} \equiv \ket{010} \equiv \ket{2} \quad\quad\quad
	\ket{1} \otimes \ket{1} \otimes \ket{0} \equiv \ket{110} \equiv \ket{6}\\
	\ket{0} \otimes \ket{1} \otimes \ket{1} \equiv \ket{011} \equiv \ket{3} \quad\quad\quad
	\ket{1} \otimes \ket{1} \otimes \ket{1} \equiv \ket{111} \equiv \ket{7}
\end{align*}
%
We call this collection the \textbf{computational basis} of our register.

However, in contrast to a classical system, a quantum register is able to be in a \textbf{state of superposition} which turns out to be the fundamental advantage for quantum computation. If for example the second qubit is set to a superposition $\ket{\Psi_{b_1}}=\tfrac{1}{\sqrt{2}}\left(\begin{smallmatrix}
+1\\-1
\end{smallmatrix}\right)$ the total state of the register will be:
%
\begin{align}
	\ket{\Psi^\text{tot}} &= \ket{\Psi_{b_2}} \otimes \ket{\Psi_{b_1}} \otimes \ket{\Psi_{b_0}}\label{eq:stateProduct}\\
			   &= \ket{0} \otimes \left[ \tfrac{1}{\sqrt{2}} \left(\ket{0} - \ket{1}\right) \right] \otimes \ket{1}\\
			   &= \tfrac{1}{\sqrt{2}} \left[ \ket{001} - \ket{011}   \right]\\
			   &\equiv \tfrac{1}{\sqrt{2}} \left[ \ket{1} - \ket{3}   \right]\label{eq:stateProduct2}
\end{align} 
%
%Entangled states
Eq.\,\ref{eq:stateProduct2} is always reducible to a (tensor) product of three single states, as Eq.\,\ref{eq:stateProduct} suggests. This is not always the case. Consider the 2-qubit system where
%
\begin{align}
	\ket{\Psi^\text{ent}} = \tfrac{1}{\sqrt{2}}  \left[ \ket{00} + \ket{11} \right].
\end{align}
%
There is no way to separate this wave function into a (tensor) product of two states
$\{ \ket{\Psi_{b_1}}, \ket{\Psi_{b_0}} \}$. Thus, the state $\ket{\Psi^\text{ent}}$ is called \textbf{entangled}.

\subsection{Quantum Gates}\label{sec:Quantum gates}
After defining the quantum register, we now want to process it through a number of so-called quantum gates. These are \textbf{unitary operations} applied to our register in order to change its total state $\ket{\Psi^\text{tot}}$. Since we work in the Hilbert space, all our operations are \textbf{linear}, therefore we can represent any gate working on a $n$-qubit register by a $N \times N$ matrix.

In the following subsections we will first introduce the most important gates used in our project, and then speak about generalisations of these gates for bigger registers.

\subsubsection{Pauli-X Gate}
The first example for a simple 1-qubit gate is the Pauli-X gate. It simply maps the state $\ket{0}\rightarrow\ket{1}$ and vice versa and is therefore equivalent to the logic \textsc{Not}. The representing matrix in the computational basis $\{\ket{0}, \ket{1}\}$ is:
%
\begin{align}
	& X =
	\begin{pmatrix}
		0 & 1\\
		1 & 0
	\end{pmatrix}\\
	& X \ket{0} = \ket{1}\\
	& X \ket{1} = \ket{0}\\
%
\end{align}
\begin{align*}
	\Qcircuit @C=.7em @R=.7em {
		  \lstick{\ket{b}}    & \gate{X} & \qw & \rstick{\ket{1-b}}
	}
\end{align*}
%
%However, this gate exists in exactly the same form for classical computation.

\subsubsection{Hadamard Gate}
A common gate in quantum computation is the Hadamard gate. It performs the Hadamard transformation on a single qubit system in the following way:
%
\begin{align}
	H & = 
		\frac{1}{\sqrt{2}}
		\begin{pmatrix}
			1 & 1\\
			1 & -1
		\end{pmatrix}\\
	H \ket{0} & = \tfrac{\ket{0} + \ket{1}}{\sqrt{2}}\\
	H \ket{1} & = \tfrac{\ket{0} - \ket{1}}{\sqrt{2}}
\end{align}
\begin{align*}
	\Qcircuit @C=.7em @R=.7em {
		  \lstick{\ket{b}}    & \gate{H} & \qw & \rstick{\tfrac{1}{\sqrt{2}}\left[(-1)^b \ket{b} + \ket{1-b}\right]}
	}
\end{align*}
%
The Hadamard gate is a `real' quantum gate since it is able to set the state to a superposition of basic states.

For a $n$-qubit system it is necessary to define on which qubit a gate is acting. In the following we will use the subscript to depict this: The gate $G_k$ is acting on the $k$-th qubit.

Note that a combination of Hadamard gates acting on every single qubit in a $n$-qubit register with initial state $\ket{\Psi}=\ket{00...0}$ will lead to an \textbf{uniform superposition} of all basic states:
%
\begin{align}
	\left(  \prod_{k=0}^{n-1} H_k  \right) \ket{\Psi}
	&= H_{n-1} \underbrace{\ket{b_{n-1}}}_{=\ket{0}} \otimes ... \otimes H_{0} \underbrace{\ket{b_{0}}}_{=\ket{0}}\\
	&= \tfrac{\ket{0} + \ket{1}}{\sqrt{2}} \otimes ... \otimes \tfrac{\ket{0} + \ket{1}}{\sqrt{2}}\\
	&= 2^{-\frac{n}{2}} \sum_{k=0}^{N-1} \ket{k}
\end{align}

%

\subsubsection{Phase Gate}
The Hadamard gate already uses special properties of quantum computation, but all operations are part of the real subspace of the Hilbert space. In general the gates and quantum register can operate on a complex vector space. The phase gate is such a gate which is defined for a single qubit system as:
%
\begin{align}
	R_\phi & = 
			\begin{pmatrix}
				1 & 0\\
				0 & e^{i\phi}
			\end{pmatrix}\\
	R_\phi \ket{0} & = \ket{0}\\
	R_\phi \ket{1} & = e^{i\phi} \ket{1}
\end{align}
\begin{align*}
	\Qcircuit @C=.7em @R=.7em {
		  \lstick{\ket{b}}    & \gate{R_\phi} & \qw & \rstick{e^{i b \phi}\ket{b}}
	}
\end{align*}
%

\subsubsection{Control Gates}
Apart from single qubit gates, there are also control gates. The gate 

\subsubsection{Extension to bigger registers}
As roughly mentioned before, any single qubit gate can by applied to the $k$th qubit of a $n$-qubit register. The challenge now is how to construct a matrix representation of a single qubit gate is when it is applied to a register with multiple qubits. Mathematically, this involves taking the tensor product of the matrix representing the gate on the desired target qubit with the identity on others. Consider the example of applying a single qubit gate $G$ on the left qubit in a 2-qubit system. The resulting matrix $G_\text{tot}$ is:
%
\begin{align}
	G_\text{tot} 
	&= G_1 \otimes \underbrace{G_0}_{=\mathbb{I}_2}\\
	&=
	\begin{pmatrix}
		g_{00} & g_{01}\\
		g_{10} & g_{11}\\
	\end{pmatrix}
	\otimes
	\begin{pmatrix}
		1 & 0\\
		0 & 1\\
	\end{pmatrix}\\
	&=
	\begin{pmatrix}
		g_{00} \left(\begin{smallmatrix}1& 0\\ 0& 1\end{smallmatrix}\right) & g_{01} \left(\begin{smallmatrix}1& 0\\ 0& 1\end{smallmatrix}\right)\\
		g_{10} \left(\begin{smallmatrix}1& 0\\ 0& 1\end{smallmatrix}\right) & g_{11} \left(\begin{smallmatrix}1& 0\\ 0& 1\end{smallmatrix}\right)\\
	\end{pmatrix}
	\\
	&=
	\begin{pmatrix}
		g_{00} & 0 & g_{01} & 0\\
		0 & g_{00} & 0 & g_{01}\\
		g_{10} & 0 & g_{11} & 0\\
		0 & g_{10} & 0 & g_{11}\\
	\end{pmatrix}
\end{align}
%
%\begin{align*}
%	\Qcircuit @C=.7em @R=.7em {
%		  \lstick{\ket{b_0}}    & \gate{G_0} & \qw & \rstick{\ket{b_0}}\\
%		  \lstick{\ket{b_1}}    & \gate{G_1} & \qw & \rstick{\ket{b_1}}
%	}
%\end{align*}
%
The general expression for $n$-qubit systems is analogous:
%
\begin{align}
	G_\text{tot} 
	&= G_{n-1} \otimes ... \otimes G_k \otimes ...\otimes G_0\\
	&= \mathbb{I}_2 \otimes ... \otimes
	\left(
	\begin{smallmatrix}
		g_{00} & g_{01}\\
		g_{10} & g_{11}\\
	\end{smallmatrix}
	\right)
	\otimes ...\otimes \mathbb{I}_2
\end{align}
%

Instead of carrying out this tensor product explicitly, which is likely to be computationally expensive and inefficient, we notice that the linear operation serves as an active transformation of the state vector. From linear algebra, we know the columns within the matrix that describes such a transformation are the basis vectors of the transformed basis (or the new basis) expressed in terms of the old basis. Therefore, we can construct the matrix for this transformation easily if we know how each basis state in the new basis is described by the old basis. 

This turns out to be a simple task to do on a classical computer using bitwise operations, provided that we know how the gate operates on a single qubit. Consider a $n$-qubit system and we wish to apply an arbitrary gate $G$ on the $k$th qubit. Suppose $G$ has the following effect on the states $\ket{0}$ and $\ket{1}$ of a single qubit:
\begin{align}
	G\ket{0} &= \alpha_0 \ket{0} + \beta_0 \ket{1}\\
	G\ket{1} &= \alpha_1 \ket{0} + \beta_1 \ket{1}
\end{align} 
We can write this more compactly as
\begin{align}
 G\ket{y} = \alpha(y)\ket{0} + \beta(y)\ket{1}, \label{twostates}
\end{align}
 where we let $\alpha(0) = \alpha_0$, $\alpha(1) = \alpha_1$ and similarly for $\beta$.
We wish to find the relationship between the new basis $\ket{x}'$ and the old basis $\ket{x}$ such that $\ket{x}' = G\ket{x}$. For this discussion, it would be most convenient to write each basis state in terms of the computational basis, which is $\ket{x} \equiv \ket{x_{n-1}x_{n-2}\dotsm x_0}$ where $x = x_{n-1}2^{n-1} + x_{n-2}2^{n-2} + \dotsb + x_0 2^0$. The new basis state $\ket{x}'$ is therefore given by:
\begin{align}
	\ket{x}' &= G\ket{x} = G\left(\ket{x_{n-1}} \ket{x_{n-2}} \dotsm \ket{x_k} \dotsm \ket{x_0}\right)\\
	&= \ket{x_{x-1}} \otimes \ket{x_{n-2}} \otimes \dotsm \otimes G\ket{x_k} \otimes \dotsm \otimes \ket{x_0}
\end{align}
where we used the fact that $G$ only operates on the $k$th qubit. Using equation \ref{twostates}, we can see that every new basis state can be described by two, and only two, basis vectors from the old basis:
\begin{align}
	\ket{x}' &= \ket{x_{n-1}} \otimes \ket{x_{n-2}} \otimes \dotsm \otimes \left(\alpha(x_k)\ket{0} + \beta(x_k)\ket{1} \right)  \otimes \dotsm \otimes \ket{x_0}\\
	&= \alpha(x_k)\ket{x_{n-1}x_{n-2}\dotsm 0 \dotsm x_0} + \beta(x_k)\ket{x_{n-1}x_{n-2}\dotsm 1 \dotsm x_0}
\end{align}

This means that there would only be two elements in each column within the matrix $G$. Let $G(i,\,j) \equiv G_{ij}$ and since $G_{ij} = \bra{i} G \ket{j}$, the two elements in column $x$ of $G$ are:
\begin{align}
	G(x_{n-1}x_{n-2}\dotsm0\dotsm x_0,\;x_{n-1}x_{n-2}\dotsm x_k\dotsm x_0) &= \alpha(x_k)\label{offResult}\\ 
	G(x_{n-1}x_{n-2}\dotsm1\dotsm x_0,\;x_{n-1}x_{n-2}\dotsm x_k\dotsm x_0) &= \beta(x_k) \label{onResult}
\end{align}
Therefore, we can find all elements of the matrix by iterating over the column index $x$, $x \in [0,\,N-1]$. We notice the value of the element depends on $x_k$, or whether the $k$th bit is $0$ or $1$. This can be found by performing the bitwise AND operation between $x$ and a \emph{mask} with value $2^{k-1}$. If the result is zero, $x_k = 0$; otherwise, $x_k = 1$. We can also toggle the $k$th bit in $x$ to find the row index of the two elements by performing an XOR operation between $x$ and the mask.

The matrix representation of a control gate can also be found using the same procedure. From the previous section, we know the operation in a control gate is only performed if the control qubits are all 1. Consider the gate $G$ that is controlled by $m$ qubits with values $c_1, c_2, \dotsc, c_m$, $c_i \in \{0, 1\}$. The new basis is related to the old basis by:

\begin{align}
	\ket{x}' = G^{c_1c_2\dotsm c_m} \ket{x} = \left\{ 
	\begin{array}{ll}
		G\ket{x}  &  \quad\textrm{if}\quad c_1 = c_2 = \dotsc = c_m = 1\\[5pt]
		\mathbb{I}\ket{x} & \quad \textrm{otherwise}
	\end{array}
	\right.
\end{align}

Hence, we can still iterate over the column index $x$ to find the elements, except we need to check whether each of the control bits $\{c_i\}$ in $x$ is 1 using the AND operation as described above. If the bits are all 1, we would obtain the two elements as stated in equation \ref{offResult} and \ref{onResult}; otherwise, the new basis state would be the same as the old basis state, so the only non-zero element in column $x$ would be $G(x,\,x) = 1$.

\subsubsection{Gate representations}
The resulting matrix $G_\text{tot}$ is in general a $N \times N$-matrix with two and only two non-zero entries in every row and column. That means that only $2\cdot 2^n$ of $2^{n^2}$ entries are non-zero. The ratio is $2^{1-n}$ which rapidly goes towards zero for big $n$. Thus, most entries of the gate matrices will be zero.

This leads to the consideration of the following three possible representations:
\begin{enumerate}
	\item \textbf{Dense matrix representation}\\
		A dense matrix representation is the standard representation, storing every single entry of a matrix. This leads to two major disadvantages in our special case:		
		\begin{enumerate}
			\item \textit{Memory}\\
			A classical computer reserves a certain amount of memory for every entry of a conventional matrix, no matter if the value is zero or non-zero. Therefore using dense matrices for big quantum registers might cause a serious lack of working memory.
			\item \textit{Calculation}\\
			We get a lot of trivial (and unnecessary) calculations using the standard matrix multiplication rule.
		\end{enumerate}
		The quantum register, however, has mostly non-zero entries for most of the steps of the usual algorithms.
	\item \textbf{Sparse matrix representation}\\
		A sparse matrix representation only stores non-zero elements of a matrix in a list. Therefore every non-zero element requires a positioning index and the number itself to store. This representation is particularly useful in representing the gates because there are a only two non-zero elements in each column of a gate matrix. Therefore on an N-qubit register a Sparse matrix representation will only require roughly $4N$ storage elements (the index and value of each non zero element in N columns). This is significantly smaller than the $N^2$ required elements in a dense matrix both speeds up computation and decrease memory pressure for higher values of N.
	\item \textbf{Functional representation}\\
		Another representation of the gates that deviates slightly from the underlying maths representation is to use a functional representation of the gates. The key difference between a matrix and functional representations is that a functional representation doesn't generate a final gate matrix to multiply to the register. Instead the elements for each column are calculated iteratively and then applied to the necessary elements of the register. This significantly decreases memory pressure as the program no longer has to create a matrix for each gate in the circuit. However, the increased computational complexity can make the program run more slowly in some cases. (See \hyperref[sec:Results]{Results} )
		
\end{enumerate}



%This is a hint that a (dense) matrix representation for single qubit gates acting on a big quantum register is an incredibly inefficient way of storing gate data.


\subsection{Quantum algorithms}\label{sec:Quantum algorithms}

After defining quantum gates it is now simple to predict the next step: A so-called quantum algorithm defines in what manner a quantum register is applied to a sequence of quantum gates in order to achieve a certain computation result. Two very important algorithms are Grover's algorithm and Shor's algorithm which we are going to introduce next.

% - Explain why certain problems are rendered tractable by quantum computation with reference to the relevant concepts in quantum theory.

%Explain how Grover’s algorithm works, and discusse its limitations

\subsubsection{Grover's Algorithm}
Grover's algorithm is also known as the quantum search algorithm. On a classical computer, searching through a non-ordered list with $N$ entries would require $O(N)$ operations. This can be sped up to $O(\sqrt{N})$ operations using a quantum circuit implementing Grover's algorithm. Different from normal search operations, this algorithm searches through the $index$ of the elements (which ranges from $0$ to $N-1$) rather than the elements themselves. The index of an element corresponds to a basis state in the register. By using a `black box' (also known as an \emph{oracle}) which can $recognise$, without $knowing$, the states associated with the solutions of the search problem, the algorithm finds the solutions by repeatedly performing a certain set of transformations on the register to maximise the probability of measuring the solution states.

Suppose we want to search through a list of $N$ elements, and there are $M$ solutions to the search, where $ 1 \leq M \leq N$. For simplicity, let $N = 2^n$ so that the index of the elements can be exactly represented by $n$ qubits in the quantum register. As mentioned above, the oracle has the ability to recognise the solution states. This is signalled by the change in state of a single qubit $\ket{q}$ in the oracle. Specifically, if $\ket{x}$ is the basis state associated with the index of a particular element, the oracle performs the following operation:

\begin{align}
	\ket{x} \ket{q} \xrightarrow{O} \ket{x} \ket{q \oplus f(x)}
\end{align}
where $\oplus$ denotes the addition modulus 2, or XOR, operation. Hence, the
By initialising the oracle qubit
The key object in Grover's algorithm is the quantum \emph{oracle}, which has the ability to $recognise$ the solution states without \emph{knowing} them. Since we are interested in the algorithm itself, the exact mechanism how the oracle can identify the solution states is unimportant. The oracle marks the solution states by flipping the sign of the state.  Let $\ket{x}$ be one of the basis states and let $f(x) = 1$ if $\ket{x}$ is a solution state and $f(x) = 0$ if it is not a solution. The oracle performs the following linear operation (denoted as $O$):
\begin{align}
	\ket{x} \xrightarrow{O} (-1)^{f(x)}\ket{x}
\end{align}

What needs to be done now is to maximise the probability of observing one of the solution states. This cannot be achieved by re-applying the oracle right away, as this would undo the marking. Grover designed an algorithm to achieve this effect, and it is known as the Grover's diffusion operation. The procedure of the algorithm is as follows:


The algorithm requires repeated applications of a set of operations on the circuit to achieve the desired result. Each iteration consists of the following steps:

\begin{enumerate}

	\item Apply the oracle $O$
	\item Apply the Hadamard operation on all qubits $H^{\otimes n}$ \label{step2}
	\item Perform a phase shift of -1 on every state of the computational basis except $\ket{0}$:
		\begin{align}
			\ket{x} \quad 
			\xrightarrow 
			\quad -(-1)^{\delta_{x0}}\ket{x}
		\end{align}
	\item Apply the Hadamard operation on all qubits again $H^{\otimes n}$ \label{step4}
\end{enumerate}
Step \ref{step2} to step \ref{step4} is also known as the \emph{inversion about mean} operation. Mathematically, this iteration can be written compactly as:
\begin{align}
	G = \left(2\ket{\psi}\bra{\psi} - \mathbb{I}\right)O.
\end{align}

\begin{figure}[H]
\begin{align*}
 \Qcircuit @C=1em @R=.7em {
                   &         &                      &                         &                      & \ustick{\text{Grover diffusion operator}} \\
  \lstick{\ket{0}} & /^n \qw & \gate{H^{\otimes n}} & \multigate{1}{U_\omega} & \gate{H^{\otimes n}} & \gate{2 \ket{0^n}\bra{0^n} - I_n}         & \gate{H^{\otimes n}} & \qw & \cdots & & \meter & \cw \\
  \lstick{\ket{1}} & \qw     & \gate{H}             & \ghost{U_\omega}        & \qw                  & \qw                                       & \qw                  & \qw & \cdots & \\
                   &         &                      &                         &                      & \dstick{\text{Repeat $O(\sqrt{N})$ times}}
  \gategroup{2}{5}{2}{7}{.7em}{^\}}
  \gategroup{2}{4}{3}{10}{.7em}{_\}}
 }
\end{align*}
\caption{Circuit of Grover's Algorithm\citeS{GroversAlgo}}
\label{fig:CircuitGrover}
\end{figure}
Fig.\,\ref{fig:CircuitGrover} shows a schematic circuit diagram for Grover's algorithm.

To determine the number of times the diffusion operation should be applied, we need to first
Geometrically, the iteration performs a rotation of the state vector $\ket{\Psi}$ towards the vector representing a uniform superposition of the solution states on the plane spanned by the 

\begin{align}
	\ket{\alpha} &\equiv \frac{1}{\sqrt{N-M}} \sum_\textrm{solutions} \ket{x}\\
	\ket{\beta} &\equiv \frac{1}{\sqrt{M}} \sum_\textrm{non solutions} \ket{x}
\end{align}
Substituting these to the state vector gives:
\begin{align}
	\ket{\Psi} &= \sqrt{\frac{N-M}{N}}\ket{\alpha} +\sqrt{\frac{M}{N}}\ket{\beta}
\end{align}

\paragraph{Limitations of Grover's Algorithm}

\subsubsection{Shor's Algorithm}

Shor's algorithm was published 1994 by Peter Shor and proposes an procedure for factorising integers. It is able to find non-trivial divisors in polynomial time (that means, that there exists polynomial function which is the upper time limit for the calculation), whereas classical algorithms are significantly above polynomial time (though sub-exponential).

This has vast impact on today's cryptography: Many encryption systems (like RSA)\citeS{RSAcrypto} rely on the fact, that it is impossible to factorise integers in a reasonable time. Shor's algorithm showed that it is (theoretically) possible for quantum computers, however the practical difficulties of building a real quantum computer are still preventing Shor's algorithm to undermine modern cryptography.

Shor's algorithm belongs to the Monte-Carlo algorithms which means that it is based on probabilistic calculations. Therefore in some cases it might lead to undesired results.



Fig.\,\ref{fig:CircuitShor} shows a schematic circuit diagram for Shor's algorithm.

\begin{figure}[H]
\begin{align*}
 \Qcircuit @C=.7em @R=.7em {
  \lstick{\ket{0}}    & \gate{H} & \qw & \qw               & \qw               & \qw & \cdots & & \ctrl{4}               & \multigate{3}{\textrm{QFT}_{2n}^{-1}} & \qw  & \meter & \cw \\
  \lstick{\vdots\ \ } & \vdots   &     &                   &                   &     &        & &                        &    \pureghost{\textrm{QFT}_{2n}^{-1}} &      & \vdots &     \\
  \lstick{\ket{0}}    & \gate{H} & \qw & \qw               & \ctrl{2}          & \qw & \cdots & & \qw                    &        \ghost{\textrm{QFT}_{2n}^{-1}} & \qw  & \meter & \cw \\
  \lstick{\ket{0}}    & \gate{H} & \qw & \ctrl{1}          & \qw               & \qw & \cdots & & \qw                    &        \ghost{\textrm{QFT}_{2n}^{-1}} & \qw  & \meter & \cw \\
  \lstick{\ket{1}}    & /^n \qw  & \qw & \gate{U{a^{2^0}}} & \gate{U{a^{2^1}}} & \qw & \cdots & & \gate{U{a^{2^{2n-1}}}} & \qw
 }
\end{align*}
\caption{Circuit of Shor's Algorithm\citeS{ShorsAlgo}}
\label{fig:CircuitShor}
\end{figure}

\begin{figure}[H]
\begin{align*}
 \Qcircuit @C=1em @R=.7em {
  \lstick{\ket{x_n}}     & \qw                             & \ctrl{6}               & \ctrl{5}               & \qw & \cdots & & \ctrl{3}               & \qw & \cdots & & \ctrl{1}         & \gate{H} & \rstick{\ket{y_1}} \qw \\
  \lstick{\ket{x_{n-1}}} & \multigate{5}{\text{QFT}_{n-1}} & \qw                    & \qw                    & \qw & \cdots & & \qw                    & \qw & \cdots & & \gate{R_{\pi/2}} & \qw      & \rstick{\ket{y_2}} \qw \\
  \lstick{\vdots\ \ }    & \pureghost{\text{QFT}_{n-1}}    &                        &                        &     &        & &                        &     &        & &                  &          & \rstick{\ \ \vdots} \\
  \lstick{\ket{x_i}}     & \ghost{\text{QFT}_{n-1}}        & \qw                    & \qw                    & \qw & \cdots & & \gate{R_{\pi/2^{n-i}}} & \qw & \cdots & & \qw              & \qw      & \rstick{\ket{y_{n-i+1}}} \qw \\
  \lstick{\vdots\ \ }    & \pureghost{\text{QFT}_{n-1}}    &                        &                        &     &        & &                        &     &        & &                  &          & \rstick{\ \ \vdots} \\
  \lstick{\ket{x_2}}     & \ghost{\text{QFT}_{n-1}}        & \qw                    & \gate{R_{\pi/2^{n-2}}} & \qw & \cdots & & \qw                    & \qw & \cdots & & \qw              & \qw      & \rstick{\ket{y_{n-1}}} \qw \\
  \lstick{\ket{x_1}}     & \ghost{\text{QFT}_{n-1}}        & \gate{R_{\pi/2^{n-1}}} & \qw                    & \qw & \cdots & & \qw                    & \qw & \cdots & & \qw              & \qw      & \rstick{\ket{y_n}} \qw
 }
\end{align*}
\caption{Circuit of Quantum Fourier Transforms\citeS{QFT}}
\label{fig:QFT}
\end{figure}

%\subsection{Building a quantum computer}\label{sec:Building a quantum computer}

% - State some of the practical challenges in building a quantum computer.

% current state-of-the-art of real quantum computers

%-----------------------------------------------------------------------------------------
% Implementation
%-----------------------------------------------------------------------------------------
%
\section{Implementation}\label{sec:Implementation}
%Describe how your program is structured
%Why have you made the design choices you did
%perhaps you could also say what you would do differently in the light of your experience
In this section we go over the approach we used to tackle the task of simulating the aforementioned concepts on a classical computer. The problem of representing many different concepts, which both built on and used one another, naturally led to a large object-oriented programme. Aside from modeling the quantum concepts that ultimately formed a simulation of a basic quantum computer this project also required the creation of the matrix libraries used in the underlying mathematics and a user interface to test and interact with the simulated computer. Thus the implementation of the program can be understood by understanding each of these three major components and how they interact. This section will begin by a discussion of what software development tools were leveraged in order to organise the project between the group members and create the simulator.  Following that is a more in depth discussion of how each component of the program is designed. (For even more detailed documentation of our project see the Javadoc documentation provided with the submission.)

\subsection{Project organisation}
%•	How tasks were distributed
% - Describing our medium-scale application program and the work of our a co-operative team.
%   How you organised your group, and how well it worked together
Prior to implementing the program an overall architecture was formed in order to define the interfaces by which each of the various parts of the program would communicate with one another. A simplified view of this architecture is provided below. The full design includes the interfaces used to communicate between these components, including the method names expected inputs and expected outputs.
\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img/QCPOverallArch.pdf}
\caption{}
\end{figure}

\subsubsection{Java}
There were many viable programming languages that could be used to implement this simulator. The primary considerations in choosing the appropriate language were the following.
\begin{enumerate}
	\item The language should readily support large object oriented design implementations
	\item The program should be able to efficiently simulate as large of a quantum register as possible
	\item The resulting program should run on as many platforms as possible
	\item All members of the group should be comfortable with the language
\end{enumerate}
The two primary languages that were ultimately considered were Java and C++. Java was chosen for two primary reasons: it provided an operating system agnostic, well-documented library for Graphical User Interface creation and more of our group members were familiar with the language. It is worth noting that a `lower level' programming language such as C++ would have allowed for more efficient memory management and optimisations but at the cost of increased code complexity. Since we only had limited time to complete our task we decided that we would forgo the speed benefits of C++ for the robustness and ease of Java.

\subsubsection{Git}
Once an architecture and programming language were decided, the next task was to implement the program as a team. The primary challenge involved in this is allowing each group member to work on the project simultaneously without interfering with each another's progress.  The primary tool used in this project to solve this problem is Git source control. Git allows many contributors to simultaneously add changes to a working code base remotely by storing the iterations of the project on both a central server and also on each contributor's local device. In addition it provides many tools to assist in simultaneous development such as previous version recovery, conflict resolution (when multiple contributors change the same lines of code in a file), and branch creation (which allows a developer to work in their own version of a project without seeing changes made by other contributors).   


\subsection{Development environment}
% - Describing collaborative development tools (Java) (such as version control systems (Git)).
%•	Java Git Eclipse
Two primary software solutions were used in order to implement our project.  The first was Github, which was used to host the Git repository and also functioned as a communication tool. The second was Eclipse and Integrated Development Environment (IDE), which was the primary text editor and compiler used to create and test the program. Eclipse also contained a built in unit-testing environment called JUnit. This was we used in data collection because it allowed testing that bypassed the GUI to speed up how quickly the results were obtained.

\subsubsection{Github}
As mentioned earlier Github was not only a means of hosting the git repository of our project but also one of the primary means of communication between the group members. The primary feature of the software that was leveraged for this was the issue tracker, which was used as a forum, to-do list, and bug reporting platform. 

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img/issue_example.pdf}
\caption{}
\end{figure}

\subsection{Programme structure}

%
\subsubsection{Overview}
%QProcess
% •	OO Design (include our design diagrams)
As mentioned previously, the architecture for this simulator contains three major components.
\begin{enumerate}
	\item The Quantum computer
	\item The underlying matrix library
	\item The Graphical User Interface for testing the computer
\end{enumerate}
This section will presented some overall design considerations and then will go in-depth in describing the design and implementations of each of the components.

The overall design of the quantum computer simulator requires careful consideration, as it is the backbone for running various quantum algorithms. An effective, well-structured design allows one to implement any algorithm at ease and compare the performance of the programme under different representations. Our group has identified some key specifications for the design of the computer: 
\begin{enumerate}
	\item It should be consistent with a circuit-model quantum computer. 
	\item It should allow different representations for each type of object within the computer to be changed easily (i.e. the circuit, gate and the register).
	\item It should be extendible and compatible. One should be able to implement another representation for the objects within the computer that would work with the current code.
	\item It should maximise code reusability.
	\item It should be stable and user friendly.
\end{enumerate}
The first point is fundamental as the project brief specifically asks us to create a simulator of a circuit-model quantum computer. We therefore design the programme based on the physical objects that exist in such computer. This includes the register, which is an array storing n qubits, the quantum gates, and the circuits, which consist of a series of gates that perform more complex operations on the register, such as the quantum search algorithm. These form the three main groups of classes for the computer part of the programme. 

To achieve the remaining specifications, we created an interface for each type of object in the program and adhered to common object oriented design patterns. Each interface describes the fundamental behaviours of the corresponding object that are independent of the representation. This allows objects to interact without having to be concerned about each other?s representation. It thus separates the task of representing an object and using it to build circuits for implementing the algorithms, which is key for maximising code reusability and making the programme extendible. The use of commonly used design architectures (such as the Factory Pattern and MVVM) allow for other programs to quickly understand the design and usage of the parts of the program. 

\subsubsection{The Computer}\label{sec:The Computer}
%allow indentation in enumerate environment
\newenvironment{myenumerate}{%
  \edef\backupindent{\the\parindent}%
  \enumerate%
  \setlength{\parindent}{\backupindent}%
}{\endenumerate}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img/QuantumSimDesign.pdf}
\caption{}
\end{figure}

\begin{myenumerate}
	\item \textbf{Register}\\
	As discussed in section 2, the register is consists of an array of $n$ qubits that would be manipulated by the gates. From an object-orientated design perspective, it might be tempting to create a qubit object with the register storing an array of these objects. This, however, is unphysical as qubits can be entangled and may not be separable as shown in equation. Hence, we must treat the n qubits as a single system with an array storing the complex amplitudes of each basis state from $\ket{0}$ to $\ket{N-1}$. 

The \texttt{QRegister} interface is developed with the above concept in mind. It requires any classes representing the register to have accessor methods for setting and getting the amplitudes of any of the basis states. It also requires the concrete class to have the method \texttt{measure()} for measuring the register, which is needed as a measurement is performed at the end of each circuit. We created a concrete class called \texttt{MRegister}. It stored the amplitudes of the basis state as a column vector. Since the amplitudes of most of the states would generally not be non-zero, we decided to use a regular dense matrix representation for the vector. 

	\item \textbf{Gates}\\
	All quantum gates within the circuit implements the \texttt{QGate} interface. This interface requires any gate classes to implement the method called \texttt{applyGate(QReigster reg)}, as each gate must perform an operation on the register. It also requires the class to provide info about the type of gate it is representing, which would be useful for debugging the programme.

As discussed in section 2, there are many types of single qubit gates, and their associated linear operations on the register can be represented as a matrix or a function. Furthermore, we derived a strategy for creating the representation of a single qubit gate applied to a multiple qubit register that is general for any types of gate, requiring only the knowledge of how the gate operates on a single qubit; therefore, it seems natural to create an abstract class for the two representations of the gate, which are \texttt{MGate} for matrix representation and \texttt{FGate} for functional representation.

The \texttt{MGate} has a method called \texttt{initGate()} which creates the matrix representation of any single qubit gate. It requires . It implements the applyGate() method by performing the matrix multiplication of the register’s state vector with the gate matrix. The subclasses of MGate include: MXGate, MYGate, MZGate, MPhaseGate, MSGate, and MTGate.

\setlength{\extrarowheight}{3pt}
\begin{table}[h]
\begin{center}
\begin{tabular}{c | c | c}
	Gate & Matrix Rep. Class & Functional Rep. Class \\ \hline
	$G^H$ & \texttt{MHGate} & \texttt{FHGate} \\ 
	$G^{not}$ & \texttt{MNOTGate} & \texttt{FNOTGate} \\
	$G^{X}$ & \texttt{MXGate} & \texttt{FXGate} \\
	$G^{Y}$ & \texttt{MYGate} & \texttt{FYGate} \\
	$G^{Z}$ & \texttt{MZGate} & \texttt{FZGate} \\
	$G^{S}$ & \texttt{MSGate} & \texttt{FSGate} \\
	$G^{T}$ & \texttt{MTGate} & \texttt{FTGate} \\
	$G^{\phi}$ & \texttt{MPhaseGate} & \texttt{FPhaseGate} \\	
\end{tabular}
\caption{A complete list of gates implemented in the programme.}
\end{center}
\end{table}
	We know the representation of the gate would depend on the qubit that it is applied to in the register (i.e. the target qubit) and whether there are control qubits associated with gate. This leads to two options for designing the gates:
\begin{enumerate}[(a)]
	\item Construct a general form of the gate that would require the specification of the target and control qubits when it is applied.
	\item Construct a specific form of the gate that would only work for a specific target and set of control qubits.
\end{enumerate}
Although the first option keeps the gate class generic and more flexible, it would require computing the representation every time the gate is used. This may lead to a significant increase in computation time, hindering the programme performance. The latter option does not have such problem, as the gates are pre-programmed to apply to a specific target, but it has the unwelcoming side effect of consuming more memory, as more data are stored at the same time (notice this is only significant to matrix representation).  We decided to design our gates based on the second option, as it has the advantage of not requiring a list of . Nevertheless, this highlights the memory-computation time trade-off problem which is a key computational issue in this programme.

	\item \textbf{Circuits}\\
	A quantum circuit comprises of a series of gates that perform more complicated operations on the register. All circuits classes in the programme implements the QCircuit interface. They are required to implement the applyCircuit(QRegister reg) method, as they would perform some operations on the register. To allow one to build a general circuit with gates of different representations, we created the GateByGateCircuit class. 
	
	\item \textbf{Implementation of the Quantum Algorithms}\\
	
\end{myenumerate}

\subsubsection{Matrix}
After deciding that we wanted to implement a variety of gate implementations. We decided that for our code to be as user friendly as possible we should be able to switch between our two different matrix representations by only changing a single argument that is passed to the Matrix package. The package should hide the representation from the user and deal with all of the messiness internally.

To achieve this we created an abstract class \texttt{Matrix} which is then implemented by all of our concrete matrix representations. The user only ever has to deal with this abstract class. This presented some challenges in implementing this design. The first challenge we encountered was how to call the constructors for the different implementations from a single method call, where one of the arguments decided the type of the Matrix. To solve this problem we employed a simple factory design pattern. Our \texttt{MatrixFactory} contains a static method, \texttt{MatrixFactory.create(int i, int j, String type)} which returns a matrix of the type specified in the by the string passed in the method.

The \texttt{Matrix} class contains methods for all of the matrix manipulations we require in our project. This is mainly involves getting and setting elements and multiplication of matrices. Each of the concrete implementations of Matrix override the get and set methods in Matrix as they need to be written specifically for the data structure which each implementation used.

The two main types of matrices we implemented were dense and sparse matrices. The dense matrix itself comes in two different types: real and complex. These two share some common features such as the fact that each element is explicitly stored even if it is a zero. This contrasts with the sparse matrix as only non-zero elements and their indices are stored.

We made several choices in our data structures which are related to the performance of the dense matrices. Firstly we decided that the overhead created by 2 dimensional arrays is too much as it results in more memory lookups and more cache misses. This can be reduced by using a single array to store all the matrix entries. It then requires some trivial arithmetic to retrieve the array indices (element read and writes are still $O(1)$ as with multi-dimensional arrays). The cost of calculating these indices is lower than the time wasted on cache misses. 
The next optimisation we implemented was not storing complex numbers in a complex object as it would again introduce a non-negligible amount of overhead, both in terms of object allocation and a general memory overhead associated with every Java object.

Our sparse matrix implementation contains both a general sparse matrix class as well as a specially optimised class designed for gates. In section 666.666 we saw that each gate can be represented by a matrix containing two elements in each column. This allowed us to design a data structure specifically tailored towards this problem.

The \texttt{SparseGateMatrix} class only stores the non-zero entries in the matrix. As we know each column only contains 2 entries, it is enough to store the value and the row index of the element. As long as the entries for each column are stored in order, the true index can be easily recovered with trivial arithmetic in $O(1)$ operations.

The matrix multiplication is dealt with in a separate helper class called \texttt{MatrixMultiply}. It contains a very general and naïve implementation of a matrix multiplication algorithm. It then contains further methods which are optimised towards each of our implementations, the most important of these being the multiplication of a complex matrix by a sparse matrix representing a gate. This method is where almost of the computational resources are spent when applying our circuits to the register. It turns out that it is possible to write a more efficient sparse-dense multiplication algorithm if we consider $\ket{\psi}$* operator rather than operator * $\bra{\psi}$. This is because in this case we know that there are only 2 elements in reach row of the sparse matrix which are very quick to access as they will be located next to each other in the system memory. It is then only required to find the 2 corresponding elements in the register to be able to calculate the corresponding element in the answer. While this approach incurs a small overhead due to having to convert from $\bra{\psi}$ to $\ket{\psi}$ and back again at the end, this can be minimised very easily and the final code runs faster than if this approach was not used.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img/MatrixDesign.pdf}
\caption{}
\end{figure}

\subsubsection{Graphics User Interface}
The Graphics User Interface (GUI) for this program is constructed through the use of the Java swing library and one external, open source library for graphing called JFreeChart. In designing the GUI there were a couple of goals in mind. 
\begin{enumerate}
	\item Make it easy to use
	\item Have it display as much of the potential of the simulator as possible
	\item Ensure it?s usage does not significantly slow down the simulation process
\end{enumerate}
To accomplish the first goal the entire interface is limited to a small selection of buttons and drop down menus that requires the user to do very little to start a simulation. The GUI also dynamically changes itself in an attempt to instruct the end-user on how to use the program. The program also has a built in help window with instructions on how to perform the various simulations.

To accomplish the second and third goals, a variation of the Model-View-ViewModel interface was implemented.  In this architecture, the Model (i.e. the quantum simulator) would communicate relevant data changes to the ViewModel (QViewModel.java) through static methods. The ViewModel would then perform any necessary conversion or reinterpretation of the data and then would instruct the view (i.e. the animations and console window) to update what it is displaying. This accomplished the goal of not slowing down the program because the simulation code does not need to wait for the GUI to render to continue it?s simulation. It achieves the second goal because it provides a simple interface for the people working on the model code to use in order to make changes to the GUI and facilitates communication between the View and Model programmers.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{img/GuiDiagram.pdf}
\caption{}
\end{figure}

The class QuantumGuiFrame contains all of the other created classes that ultimately form the overall GUI. These include QuantumMenuBar and QuantumGuiPanel (which contains a QAnimationTabbedPane). This structure is diagrammed below.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{img/GuiOverall.pdf}
\caption{}
\end{figure}

\subsection{Programme execution}
The execution flow of the program is a two threaded system but could be expanded to many more threads in the event this program is extended to have multi-core or GPU support. When the program is started the main function in QuantumGuiFrame creates the GUI and waits for user input.  Once the user has selected the type of simulation and the associated data they will then press the start button which will create a QProcess object.  This QProcess class will launch a new thread in it?s constructor that will create a quantum circuit based off of the specifications that the user provided and run that circuit on the target data. The GUI thread and the simulation thread will then run in parallel until the simulation is complete. As the simulation runs it updates the GUI informing the user of the progress through various animation elements and a console window.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img/program_example.pdf}
\caption{}
\end{figure}

%-----------------------------------------------------------------------------------------
% RESULTS
%-----------------------------------------------------------------------------------------
%
\section{Results}\label{sec:Results}
% - Documentation that is comprehensible to a group of different programmers.

\subsection{Grover's Algorithm}\label{sec:Grover}
%Plot of Results
\subsubsection{Rotation of the state vector}


\begin{figure}[H]
	\begin{minipage}{0.33\textwidth}
		\includegraphics[width=\textwidth]{img/pic_0.png}
		\subcaption{Iteration 1 (start)}
	\end{minipage}
	\begin{minipage}{0.33\textwidth}
		\includegraphics[width=\textwidth]{img/pic_3.png}
		\subcaption{Iteration 4}
	\end{minipage}
	\begin{minipage}{0.33\textwidth}
		\includegraphics[width=\textwidth]{img/pic_6.png}
		\subcaption{Iteration 7}
	\end{minipage}\\
	\begin{minipage}{0.33\textwidth}
		\includegraphics[width=\textwidth]{img/pic_9.png}
		\subcaption{Iteration 10}
	\end{minipage}
	\begin{minipage}{0.33\textwidth}
		\includegraphics[width=\textwidth]{img/pic_12.png}
		\subcaption{Iteration 13}
	\end{minipage}
	\begin{minipage}{0.33\textwidth}
		\includegraphics[width=\textwidth]{img/pic_13.png}
		\subcaption{Iteration 14 (end)}
	\end{minipage}
	\caption{Depiction of Grover's Algorithm: The green vector depicts the non-solution vector, the blue vector depicts the vector of the solution. The red vector is the projection of the current state. With every consecutive iteration the state vector rotates towards the solution state.}
	\label{grover_rotation}
\end{figure}

\subsubsection{Computational time}

Fig.\,\ref{grover_time_performance} shows the computational time of Grover's algorithm. All the measurements were executed on the same computer by varying the number of qubits $n$ for the three different representations.

We note the following observations:
\begin{itemize}
	\item\textbf{Dense representation at a disadvantage}\\
	One can see that the dense representation is the slowest one since for already $n\geq 10$ first noticeable computation times occur whereas the algorithm using functional and spare representation is still immediately executed. However, when they start to show noticeable computational times, the dense representation already takes a unbearable amount of time.
	\item\textbf{Spare vs. functional representation}\\
	Considering computational time the sparse representation is superior to the functional representation. It appears to be roughly a factor 2, but since we don't have data for bigger registers, this quantitative observation is quite vague.
	\item\textbf{Exponential behaviour}\\
	All three representations show an exponential behaviour. To illustrate the point we plotted the same data in a log-plot (Fig.\,\ref{grover_time_performance_log}) and got a linear relation.
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{img/Grover_Time_Performance.eps}
	\caption{Computational time of Grover's Algorithm in nanoseconds as a function of the quantum register size for the three different forms of representation (dense, sparse, functional).}
	\label{grover_time_performance}
\end{figure}




\subsection{Shor's Algorithm}\label{sec:Shor}


%-----------------------------------------------------------------------------------------
% DISCUSSION
%-----------------------------------------------------------------------------------------
%
\section{Discussion}\label{sec:Discussion}

\subsection{Matrix or functional representation}

\subsection{Improvements and further steps}

%-----------------------------------------------------------------------------------------
% CONCLUSION
%-----------------------------------------------------------------------------------------
%
\section{Conclusion}


%-----------------------------------------------------------------------------------------
% APPENDIX
%-----------------------------------------------------------------------------------------
%
\section{Appendix}

\subsection{Grover's Algorithm}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{img/Grover_Time_Performance_log.eps}
	\caption{Computational time (log-scale) of Grover's Algorithm in nanoseconds as a function of the quantum register size for the three different forms of representation (dense, sparse, functional). Note that only the behaviour for bigger registers is meaningful (linear).}
	\label{grover_time_performance_log}
\end{figure}

\subsection{Details}
The data for the computational time (Fig.\,\ref{grover_time_performance} and Fig.\,\ref{grover_time_performance_log}) was collected on a:

\begin{quotation}
	Intel i5 3570@3.4\,GHz\quad\quad 2x4\,GB 1600\,Mhz Ram \quad\quad Windows 7
\end{quotation}

	


%

\newpage

\phantomsection
\addcontentsline{toc}{section}{References}

\nocite{Perry2012}
\nocite{BasicConceptsQC}

\phantomsection\label{sec:References}
\bibliographystyle{plaindin}
\bibliography{lit}


\end{document}